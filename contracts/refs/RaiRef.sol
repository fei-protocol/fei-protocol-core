// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import "../pcv/reflexer/IGebSafeManager.sol";

abstract contract RaiRef {

    uint256 internal constant WAD = 10**18;
    uint256 internal constant RAY = 10**27;

    /// @notice SAFE collateral type
    bytes32 internal constant COLLATERAL_TYPE = "ETH-A";

    /// @notice the address of system coin
    address internal _systemCoin;

    /// @notice the referenced collateral gateway
    ICollateralJoin1 internal _collateralJoin;

    /// @notice the referenced coin gateway
    ICoinJoin internal _coinJoin;

    /// @notice the referenced SAFE helper
    IGebSafeManager public safeManager;

    /// @notice SAFE Id generated by SAFE helper contract
    uint256 public safeId;

    /// @notice RaiRef constructor
    /// @param collateralJoin_ ETH collateral gateway
    /// @param coinJoin_ coin gateway (RAI <=> internal debt)
    /// @param safeManager_ SAFE Helper contract
    constructor(
        address collateralJoin_,
        address coinJoin_,
        address safeManager_
    ) {
        require(
            collateralJoin_ != address(0) && coinJoin_ != address(0) && safeManager_ != address(0),
            "RaiRef: zero address"
        );

        _coinJoin = ICoinJoin(coinJoin_);
        _collateralJoin = ICollateralJoin1(collateralJoin_);
        _systemCoin = address(_coinJoin.systemCoin());
        safeManager = IGebSafeManager(safeManager_);

        // Create a new SAFE
        safeId = safeManager.openSAFE(COLLATERAL_TYPE, address(this));
        _safeEngine().approveSAFEModification(coinJoin_);
    }

    /// @notice get safe data
    /// @return safeCollateral Total amount of collateral locked in a SAFE
    /// @return safeDebt Total amount of debt generated by a SAFE
    function safeData() public view returns (uint256 safeCollateral, uint256 safeDebt) {
        (safeCollateral, safeDebt) = _safeEngine().safes(COLLATERAL_TYPE, _safeHandler());
    }

    /// @notice deposit ETH and generates debt and receive RAI
    /// @dev ref: https://github.com/reflexer-labs/geb-proxy-actions/blob/a7bbc32da4be3991ef3d929f5ad9de243b6bf1bb/src/GebProxyActions.sol#L695
    /// @param _safeId safeID
    /// @param _collateralToLock [wad]
    /// @param _debtToGen [wad]
    function _lockETHAndGenerateDebt(
        uint256 _safeId,
        uint256 _collateralToLock,
        uint256 _debtToGen
    ) internal {
        // Join collateral to safeHandler
        if (_collateralToLock > 0) _collateralJoin.join(_safeHandler(), _collateralToLock);
        // Modify SAFE
        safeManager.modifySAFECollateralization(_safeId, int256(_collateralToLock), int256(_debtToGen));
        // Transfer internal balances and exit COIN
        if (_debtToGen > 0) {
            safeManager.transferInternalCoins(_safeId, address(this), _debtToGen * RAY);
            _coinJoin.exit(address(this), _debtToGen);
        }
    }

    /// @notice withdraw ETH in SAFE and repay debt
    /// @dev ref:https://github.com/reflexer-labs/geb-proxy-actions/blob/a7bbc32da4be3991ef3d929f5ad9de243b6bf1bb/src/GebProxyActions.sol#L366
    /// @param _safeId safeID
    /// @param _collateralToFree [wad]
    /// @param _debtToRepay [wad]
    function _freeETHAndRepayDebt(
        uint256 _safeId,
        uint256 _collateralToFree,
        uint256 _debtToRepay
    ) internal {
        // Join coin
        if (_debtToRepay > 0) _coinJoin.join(_safeHandler(), _debtToRepay);
        // Modify SAFE
        safeManager.modifySAFECollateralization(_safeId, -int256(_collateralToFree), -int256(_debtToRepay));
        if (_collateralToFree > 0) {
            // Transfer internal collateral from SAFE handler to this contract  
            safeManager.transferCollateral(_safeId, address(this), _collateralToFree);
            // Exit collateral to this contract as WETH token
            _collateralJoin.exit(address(this), _collateralToFree);
        }
    }

    /// @notice Calculate debt amount that you are willing to generate for the given parameters
    /// @param _collateral colllateral ETH amount [WAD]
    /// @param _cRatio desired collateralization ratio
    /// @return desired debt for specified parameters
    function _getDebtDesired(uint256 _collateral, uint256 _cRatio) internal view returns (uint256) {
        require(_cRatio > 0, "RaiRef: cratio zero");
        // safetyPrice is equal to RAI amount per eth, decimals 27
        (, , uint256 safetyPrice, , , ) = _safeEngine().collateralTypes(COLLATERAL_TYPE); 
        // (((wad  *  ray) / ray) * wad) / wad
        return (((_collateral * safetyPrice) / RAY) * WAD) / _cRatio;
    }

    /// @notice Calculate required collateral for the given parameters
    /// @param _safeDebt debt amount [WAD]
    /// @param _cRatio desired collateralization ratio
    /// @return required collateral
    function _getCollateralRequired(uint256 _safeDebt, uint256 _cRatio) internal view returns (uint256) {
        (, uint256 accumulatedRate, uint256 safetyPrice, , , ) = _safeEngine().collateralTypes(COLLATERAL_TYPE); // [ray, ray]
        // wad = (wad * ray / ray) * wad / wad * ray / ray
        return (((((_safeDebt * accumulatedRate) / RAY) * _cRatio) / WAD) * RAY) / safetyPrice;
    }

    function _safeEngine() internal view returns (SAFEEngineLike) {
        return SAFEEngineLike(safeManager.safeEngine());
    }

    function _safeHandler() private view returns (address) {
        return safeManager.safes(safeId);
    }
}
