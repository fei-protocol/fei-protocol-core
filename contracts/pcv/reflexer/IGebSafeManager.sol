// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.8.4;
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

abstract contract SAFEEngineLike {
    struct CollateralType {
        // Total debt issued for this specific collateral type
        uint256 debtAmount; // [wad]
        // Accumulator for interest accrued on this collateral type
        uint256 accumulatedRate; // [ray]
        // Floor price at which a SAFE is allowed to generate debt
        uint256 safetyPrice; // [ray]
        // Maximum amount of debt that can be generated with this collateral type
        uint256 debtCeiling; // [rad]
        // Minimum amount of debt that must be generated by a SAFE using this collateral
        uint256 debtFloor; // [rad]
        // Price at which a SAFE gets liquidated
        uint256 liquidationPrice; // [ray]
    }
    struct SAFE {
        // Total amount of collateral locked in a SAFE
        uint256 lockedCollateral; // [wad]
        // Total amount of debt generated by a SAFE
        uint256 generatedDebt; // [wad]
    }

    // Data about each collateral type
    mapping(bytes32 => CollateralType) public collateralTypes;
    // Data about each SAFE
    mapping(bytes32 => mapping(address => SAFE)) public safes;
    // Balance of each collateral type
    mapping(bytes32 => mapping(address => uint256)) public tokenCollateral; // [wad]
    // Internal balance of system coins
    mapping(address => uint256) public coinBalance; // [rad]
    // Amount of debt held by an account. Coins & debt are like matter and antimatter. They nullify each other
    mapping(address => uint256) public debtBalance; // [rad]

    // Total amount of debt that a single safe can generate
    uint256 public safeDebtCeiling; // [wad]
    // Total amount of debt (coins) currently issued
    uint256 public globalDebt; // [rad]
    // 'Bad' debt that's not covered by collateral
    uint256 public globalUnbackedDebt; // [rad]
    // Maximum amount of debt that can be issued
    uint256 public globalDebtCeiling; // [rad]
    // Access flag, indicates whether this contract is still active
    uint256 public contractEnabled;

    // /**
    //  * @notice safes
    //  * @param collateralType e.g. ETH-A
    //  * @param account Account
    //  */
    // function safes(bytes32 collateralType, address account) external view virtual returns (uint256, uint256);

    /**
     * @notice Allow an address to modify your SAFE
     * @param account Account to give SAFE permissions to
     */
    function approveSAFEModification(address account) external virtual;

    /**
     * @notice Transfer collateral between accounts
     * @param collateralType Collateral type transferred
     * @param src Collateral source
     * @param dst Collateral destination
     * @param wad Amount of collateral transferred
     */
    function transferCollateral(
        bytes32 collateralType,
        address src,
        address dst,
        uint256 wad
    ) external virtual;

    function transferInternalCoins(
        address,
        address,
        uint256
    ) external virtual;

    /**
     * @notice Add/remove collateral or put back/generate more debt in a SAFE
     * @param collateralType Type of collateral to withdraw/deposit in and from the SAFE
     * @param safe Target SAFE
     * @param collateralSource Account we take collateral from/put collateral into
     * @param debtDestination Account from which we credit/debit coins and debt
     * @param deltaCollateral Amount of collateral added/extract from the SAFE (wad)
     * @param deltaDebt Amount of debt to generate/repay (wad)
     */
    function modifySAFECollateralization(
        bytes32 collateralType,
        address safe,
        address collateralSource,
        address debtDestination,
        int256 deltaCollateral,
        int256 deltaDebt
    ) external virtual;

    /**
     * @notice Transfer collateral and/or debt between SAFEs
     * @param collateralType Collateral type transferred between SAFEs
     * @param src Source SAFE
     * @param dst Destination SAFE
     * @param deltaCollateral Amount of collateral to take/add into src and give/take from dst (wad)
     * @param deltaDebt Amount of debt to take/add into src and give/take from dst (wad)
     */
    function transferSAFECollateralAndDebt(
        bytes32 collateralType,
        address src,
        address dst,
        int256 deltaCollateral,
        int256 deltaDebt
    ) external virtual;
}

contract SAFEHandler {
    constructor(address safeEngine) {
        SAFEEngineLike(safeEngine).approveSAFEModification(msg.sender);
    }
}

interface IGebSafeManager {
    // SAFEId => SAFEHandler
    function safes(uint256 safeId) external view returns (address safeHandler);

    function safeEngine() external view returns (address);

    // --- SAFE Manipulation ---

    // Allow/disallow a usr address to manage the safe
    function allowSAFE(
        uint256 safe,
        address usr,
        uint256 ok
    ) external;

    // Allow/disallow a usr address to quit to the sender handler
    function allowHandler(address usr, uint256 ok) external;

    // Open a new safe for a given usr address.
    function openSAFE(bytes32 collateralType, address usr) external returns (uint256 safeID);

    // Give the safe ownership to a dst address.
    function transferSAFEOwnership(uint256 safe, address dst) external;

    // Modify a SAFE's collateralization ratio while keeping the generated COIN or collateral freed in the SAFE handler address.
    function modifySAFECollateralization(
        uint256 safe,
        int256 deltaCollateral,
        int256 deltaDebt
    ) external;

    // Transfer wad amount of safe collateral from the safe address to a dst address.
    function transferCollateral(
        uint256 safe,
        address dst,
        uint256 wad
    ) external;

    // Transfer wad amount of any type of collateral (collateralType) from the safe address to a dst address.
    // This function has the purpose to take away collateral from the system that doesn't correspond to the safe but was sent there wrongly.
    function transferCollateral(
        bytes32 collateralType,
        uint256 safe,
        address dst,
        uint256 wad
    ) external;

    // Transfer rad amount of COIN from the safe address to a dst address.
    function transferInternalCoins(
        uint256 safe,
        address dst,
        uint256 rad
    ) external;

    // Quit the system, migrating the safe (lockedCollateral, generatedDebt) to a different dst handler
    function quitSystem(uint256 safe, address dst) external;

    // Import a position from src handler to the handler owned by safe
    function enterSystem(address src, uint256 safe) external;

    // Move a position from safeSrc handler to the safeDst handler
    function moveSAFE(uint256 safeSrc, uint256 safeDst) external;

    // Choose a SAFE saviour inside LiquidationEngine for the SAFE with id 'safe'
    function protectSAFE(
        uint256 safe,
        address liquidationEngine,
        address saviour
    ) external;
}

interface ITokenJoin {
    function join(address usr, uint256 wad) external;

    function exit(address usr, uint256 wad) external;
}

interface ICollateralJoin1 is ITokenJoin {}

interface ICoinJoin is ITokenJoin {
    function systemCoin() external view returns (IERC20);

    function safeEngine() external view returns (SAFEEngineLike);
}
